#include "MAPL_Generic.h"

!=============================================================================
!BOP

! !MODULE: SU2G_GridCompMod - GOCART refactoring of the SU gridded component 

! !INTERFACE:
module SU2G_GridCompMod

! !USES:
   use ESMF
   use MAPL
   use Chem_MieTableMod2G
   use Chem_AeroGeneric
   use iso_c_binding, only: c_loc, c_f_pointer, c_ptr
   use m_StrTemplate
   use Chem_UtilMod
   use GOCART2G_Process       ! GOCART2G process library
   use GA_GridCompMod

   implicit none
   private

   integer, parameter :: instanceComputational = 1
   integer, parameter :: instanceData          = 2

   real, parameter :: OCEAN=0.0, LAND = 1.0, SEA_ICE = 2.0
   integer, parameter     :: DP=kind(1.0d0)
!  gram molecular weights of species
   real, parameter :: fMassSulfur = 32., fMassSO2 = 64., fMassSO4 = 96., &
                      fMassDMS = 62., fMassMSA = 96.
   real, parameter ::  undefval  = 1.e15   ! missing value

! !PUBLIC MEMBER FUNCTIONS:
   PUBLIC  SetServices

real, parameter ::  chemgrav   = 9.80616

! !DESCRIPTION: This module implements GOCART's Sulfer (SU) Gridded Component.

! !REVISION HISTORY:
! 08July2020  Sherman, da Silva, Darmenov, Clune -  First attempt at refactoring.

!EOP
!===========================================================================
!  !Sulfer state
   type, extends(GA_GridComp) :: SU2G_GridComp
      integer :: myDOW = -1     ! my Day of the week: Sun=1, Mon=2,...,Sat=7
      logical :: using_GMI_OH
      logical :: using_GMI_NO3
      logical :: using_GMI_H2O2
      logical :: diurnal_bb     ! diurnal biomass burning
      integer :: nymd_last = -1 ! Previous nymd. Updated daily
!     Special handling for volcanic emissions
      character(len=255) :: volcano_srcfilen
      integer :: nVolc = 0
      real, pointer, dimension(:)    :: vLat   => null(), &
                                        vLon   => null(), &
                                        vSO2   => null(), &
                                        vElev  => null(), &
                                        vCloud => null()
      integer, pointer, dimension(:) :: vStart => null(), &
                                        vEnd   => null()

   end type SU2G_GridComp

   type wrap_
      type (SU2G_GridComp), pointer     :: PTR => null()
   end type wrap_

contains

!============================================================================
!BOP

! !IROUTINE: SetServices 

! !INTERFACE:
  subroutine SetServices ( GC, RC )

!   !ARGUMENTS:
    type (ESMF_GridComp), intent(INOUT)   :: GC  ! gridded component
    integer,              intent(  OUT)   :: RC  ! return code

!    DESCRIPTION: This version uses MAPL_GenericSetServices, which sets
!     the Initialize and Finalize services to generic versions. It also
!     allocates our instance of a generic state and puts it in the 
!     gridded component (GC). Here we only set the two-stage run method
!     and declare the data services.

!   !REVISION HISTORY:
!   08July2020   E.Sherman, A.Da Silva, A.Darmenov, T.Clune  First attempt at refactoring

!EOP
!============================================================================
!

!   !Locals
    character (len=ESMF_MAXSTR)                 :: COMP_NAME
    type (ESMF_Config)                          :: cfg
    type (wrap_)                                :: wrap
    type (SU2G_GridComp), pointer               :: self
    type (Chem_Mie)                             :: this

    character (len=ESMF_MAXSTR)                 :: field_name
    character (len=ESMF_MAXSTR), allocatable    :: aerosol_names(:)

    integer                                     :: n, i, nCols, nbins
    real                                        :: DEFVAL
    logical                                     :: data_driven=.true.

    !development testing variables - to be deleted
    real, dimension(:,:), pointer       :: ptr_test

    __Iam__('SetServices')

!****************************************************************************
!   Begin...

!   Get my name and set-up traceback handle
!   ---------------------------------------
    call ESMF_GridCompGet (GC, NAME=COMP_NAME, __RC__)
    Iam = trim(COMP_NAME) // '::' // Iam

if(mapl_am_i_root()) print*,trim(comp_name),'2G SetServices BEGIN'

!   Wrap internal state for storing in GC
!   -------------------------------------
    allocate (self, __STAT__)
    wrap%ptr => self

!   Load resource file 
!   -------------------
    cfg = ESMF_ConfigCreate (__RC__)
    call ESMF_ConfigLoadFile (cfg, 'SU2G_GridComp_'//trim(COMP_NAME)//'.rc', rc=status)
    if (status /= 0) then
       if (mapl_am_i_root()) print*,'SU2G_GridComp_'//trim(COMP_NAME)//'.rc does not exist! loading SU2G_GridComp_SU.data.rc instead'
       call ESMF_ConfigLoadFile (cfg, 'SU2G_GridComp_SU.rc', __RC__)
    end if

!   process generic config items
    call self%GA_GridComp%load_from_config( cfg, __RC__)

!   process SU-specific items
    call ESMF_ConfigGetAttribute(cfg, self%using_GMI_H2O2, label='using_GMI_H2O2:', __RC__)
    call ESMF_ConfigGetAttribute(cfg, self%using_GMI_OH,   label='using_GMI_OH:',   __RC__)
    call ESMF_ConfigGetAttribute(cfg, self%using_GMI_NO3,  label='using_GMI_NO3:',  __RC__)
    call ESMF_ConfigGetAttribute(cfg, self%volcano_srcfilen,label='volcano_srcfilen:', &
                                 default='/dev/null', __RC__)

!   Is SU data driven?
!   ------------------
    call determine_data_driven (COMP_NAME, data_driven, __RC__)

!   Set entry points
!   ------------------------
    call MAPL_GridCompSetEntryPoint (GC, ESMF_METHOD_INITIALIZE,  Initialize, __RC__)
    call MAPL_GridCompSetEntryPoint (GC, ESMF_METHOD_RUN, Run, __RC__)
    if (data_driven /= .true.) then
       call MAPL_GridCompSetEntryPoint (GC, ESMF_Method_Run, Run2, __RC__)
    end if

    DEFVAL = 0.0


!   Import and Internal states if data instance 
!   -------------------------------------------
!    if (data_driven) then

! add internal and import states for data instance

!    end if ! (data_driven)

    if (.not. self%using_GMI_H2O2) then
       call MAPL_AddImportSpec(GC,               &
          SHORT_NAME = 'SU_H2O2', &
          LONG_NAME  = 'source species'  ,     &
          UNITS      = '1',                    &
          DIMS       = MAPL_DimsHorzVert,      &
          VLOCATION  = MAPL_VLocationCenter,   &
          RESTART    = MAPL_RestartSkip, __RC__) 
    end if

    if (.not. self%using_GMI_OH) then
       call MAPL_AddImportSpec(GC,             &
          SHORT_NAME = 'SU_OH', &
          LONG_NAME  = 'source species'  ,   &
          UNITS      = '1',                  &
          DIMS       = MAPL_DimsHorzVert,    &
          VLOCATION  = MAPL_VLocationCenter, &
          RESTART    = MAPL_RestartSkip, __RC__) 
    end if

    if (.not. self%using_GMI_NO3) then
       call MAPL_AddImportSpec(GC,              &
          SHORT_NAME = 'SU_NO3', &
          LONG_NAME  = 'source species'  ,    &
          UNITS      = '1',                   &
          DIMS       = MAPL_DimsHorzVert,     &
          VLOCATION  = MAPL_VLocationCenter,  &
          RESTART    = MAPL_RestartSkip, __RC__)
    end if


!   Import, Export, Internal states for computational instance 
!   ----------------------------------------------------------
    if (.not. data_driven) then
#include "SU2G_Export___.h"
#include "SU2G_Import___.h"
#include "SU2G_Internal___.h"
    end if


!   This state holds fields needed by radiation
!   ---------------------------------------------
    call MAPL_AddExportSpec(GC,                                 &
      SHORT_NAME = trim(COMP_NAME)//'_AERO',                   &
       LONG_NAME  = 'aerosols_from_'//trim(COMP_NAME),  &
       UNITS      = 'kg kg-1',                                  &
       DIMS       = MAPL_DimsHorzVert,                          &
       VLOCATION  = MAPL_VLocationCenter,                       &
       DATATYPE   = MAPL_StateItem, __RC__)

!   This state is needed by MOIST - It will contain aerosols
!   ----------------------------------------------------------
    call MAPL_AddExportSpec(GC,                                                  &
       SHORT_NAME = trim(COMP_NAME)//'_AERO_ACI',                                &
       LONG_NAME  = 'aerosol_cloud_interaction_aerosols_from_'//trim(COMP_NAME),  &
       UNITS      = 'kg kg-1',                                                   &
       DIMS       = MAPL_DimsHorzVert,                                           &
       VLOCATION  = MAPL_VLocationCenter,                                        &
       DATATYPE   = MAPL_StateItem, __RC__)

!   This bundle is needed by surface for snow albedo modification
!   by aerosol settling and deposition
!   DEVELOPMENT NOTE - Change to StateItem in future
!   ---------------------------------------------------------------
    call MAPL_AddExportSpec(GC,                                   &
       SHORT_NAME = trim(COMP_NAME)//'_AERO_DP',                  &
       LONG_NAME  = 'aerosol_deposition_from_'//trim(COMP_NAME),  &
       UNITS      = 'kg m-2 s-1',                                 &
       DIMS       = MAPL_DimsHorzOnly,                            &
       DATATYPE   = MAPL_BundleItem, __RC__)


!   Store internal state in GC
!   --------------------------
    call ESMF_UserCompSetInternalState ( GC, 'SU2G_GridComp', wrap, STATUS )
    VERIFY_(STATUS)

!   Set generic services
!   ----------------------------------
    call MAPL_GenericSetServices (GC, __RC__)

if(mapl_am_i_root()) print*,trim(comp_name),'2G SetServices END'

    RETURN_(ESMF_SUCCESS)

  end subroutine SetServices

!============================================================================
!BOP

! !IROUTINE: Initialize 

! !INTERFACE:
  subroutine Initialize (GC, IMPORT, EXPORT, CLOCK, RC)

!   !ARGUMENTS:
    type (ESMF_GridComp), intent(inout) :: GC     ! Gridded component 
    type (ESMF_State),    intent(inout) :: IMPORT ! Import state
    type (ESMF_State),    intent(inout) :: EXPORT ! Export state
    type (ESMF_Clock),    intent(inout) :: CLOCK  ! The clock
    integer, optional,    intent(  out) :: RC     ! Error code

! !DESCRIPTION: This initializes SU Grid Component.  

! !REVISION HISTORY: 
! 08July2019   E.Sherman  First attempt at refactoring

!EOP
!============================================================================
!   !Locals 
    character (len=ESMF_MAXSTR)          :: COMP_NAME
    type (MAPL_MetaComp),      pointer   :: MAPL
    type (ESMF_Grid)                     :: grid
    type (ESMF_State)                    :: internal
    type (ESMF_State)                    :: aero, aero_aci
    type (ESMF_State)                    :: providerState
    type (ESMF_Config)                   :: cfg, cf
    type (ESMF_FieldBundle)              :: Bundle_DP
    type (wrap_)                         :: wrap
    type (SU2G_GridComp), pointer        :: self

    integer, allocatable                 :: mieTable_pointer(:)
    integer                              :: i, j, nbins, nCols, dims(3), km
    integer                              :: instance
    type (ESMF_Field)                    :: field, fld
    character (len=ESMF_MAXSTR)          :: field_name, prefix, bin_index, diurnal_bb
    real, pointer, dimension(:,:)        :: lats
    real, pointer, dimension(:,:)        :: lons
    real                                 :: CDT         ! chemistry timestep (secs)
    integer                              :: HDT         ! model     timestep (secs)

    logical                              :: data_driven
    integer                              :: NUM_BANDS

    __Iam__('Initialize')

!****************************************************************************
!   Begin... 
!   Get the target components name and set-up traceback handle.
!   -----------------------------------------------------------
    call ESMF_GridCompGet (GC, grid=grid, name=COMP_NAME, config=cf, __RC__)
    Iam = trim(COMP_NAME) // '::' //trim(Iam)

if(mapl_am_i_root()) print*,trim(comp_name),'2G Init BEGIN'

!   Get my internal MAPL_Generic state
!   -----------------------------------
    call MAPL_GetObjectFromGC (GC, MAPL, __RC__)

!   Get my internal private state
!   -----------------------------
    call ESMF_UserCompGetInternalState(GC, 'SU2G_GridComp', wrap, STATUS)
    VERIFY_(STATUS)
    self => wrap%ptr

!   Get dimensions
!   ---------------
    call MAPL_GridGet (grid, globalCellCountPerDim=dims, __RC__ )
    km = dims(3)
    self%km = km

!   Get DTs
!   -------
    call MAPL_GetResource(mapl, HDT, Label='RUN_DT:', __RC__)
    call MAPL_GetResource(mapl, CDT, Label='GOCART_DT:', default=real(HDT), __RC__)
    self%CDT = CDT

!   Check whether to de-activate diurnal biomass burning (default is *on*)
!   ----------------------------------------------------------------------
    call ESMF_ConfigGetAttribute(cf, diurnal_bb, label='DIURNAL_BIOMASS_BURNING:', &
                                 default='YES', __RC__)
    diurnal_bb = ESMF_UtilStringUpperCase(diurnal_bb, __RC__)
    if (trim(diurnal_bb) == 'YES') then
       self%diurnal_bb = .true.
    else
       self%diurnal_bb = .false.
    end if

!  Load resource file and get number of bins 
!  -------------------------------------------
    cfg = ESMF_ConfigCreate (__RC__)
    call ESMF_ConfigLoadFile (cfg, 'SU2G_GridComp_'//trim(COMP_NAME)//'.rc', rc=status)
    if (status /= 0) then
      if (mapl_am_i_root()) print*,'SU2G_GridComp_'//trim(COMP_NAME)//'.rc does not exist! &
                                    loading SU2G_GridComp_SU.rc instead'
      call ESMF_ConfigLoadFile( cfg, 'SU2G_GridComp_SU.rc', __RC__)
    end if

!   Call Generic Initialize 
!   ----------------------------------------
    call MAPL_GenericInitialize (GC, import, export, clock, __RC__)

!   Get parameters from generic state.
!   -----------------------------------
    call MAPL_Get ( mapl, INTERNAL_ESMF_STATE = internal, &
                         LONS = LONS, &
                         LATS = LATS, __RC__ )

!   Is SU data driven?
!   ------------------
    call determine_data_driven (COMP_NAME, data_driven, __RC__)

!   If this is a data component, the data is provided in the import
!   state via ExtData instead of the actual GOCART children
!   ----------------------------------------------------------------
    if ( data_driven ) then
       providerState = import
       prefix = 'clim'
    else
       providerState = export
       prefix = ''
    end if

    call ESMF_StateGet (internal, 'DMS', field, __RC__)
    call ESMF_AttributeSet(field, NAME='ScavengingFractionPerKm', VALUE=self%fscav(1), __RC__)
    call ESMF_StateGet (internal, 'SO2', field, __RC__)
    call ESMF_AttributeSet(field, NAME='ScavengingFractionPerKm', VALUE=self%fscav(2), __RC__)
    call ESMF_StateGet (internal, 'MSA', field, __RC__)
    call ESMF_AttributeSet(field, NAME='ScavengingFractionPerKm', VALUE=self%fscav(4), __RC__)

!   Fill AERO State with SO4
!   ----------------------------------------
    call ESMF_StateGet (export, trim(COMP_NAME)//'_AERO'    , aero    , __RC__)
    call ESMF_StateGet (export, trim(COMP_NAME)//'_AERO_ACI', aero_aci, __RC__)
    call ESMF_StateGet (export, trim(COMP_NAME)//'_AERO_DP' , Bundle_DP, __RC__)
    call ESMF_StateGet (internal, 'SO4', field, __RC__)
    call ESMF_AttributeSet(field, NAME='ScavengingFractionPerKm', VALUE=self%fscav(3), __RC__)

    if (data_driven) then
       instance = instanceData

!      (SO4; only aerosol component; bin 003)
!      Dry deposition
       call append_to_bundle('SUDP003', providerState, prefix, Bundle_DP, __RC__)

!      Wet deposition (Convective scavenging)
       call append_to_bundle('SUSV003', providerState, prefix, Bundle_DP, __RC__)

!      Wet deposition
       call append_to_bundle('SUWT003', providerState, prefix, Bundle_DP, __RC__)

!      Gravitational Settling
       call append_to_bundle('SUSD003', providerState, prefix, Bundle_DP, __RC__)
    else
       instance = instanceComputational

!      Dry deposition
       call append_to_bundle('SUDP', providerState, prefix, Bundle_DP, __RC__)

!      Wet deposition (Convective scavenging)
       call append_to_bundle('SUSV', providerState, prefix, Bundle_DP, __RC__)

!      Wet deposition
       call append_to_bundle('SUWT', providerState, prefix, Bundle_DP, __RC__)

!      Gravitational Settling
       call append_to_bundle('SUSD', providerState, prefix, Bundle_DP, __RC__)
    end if

    self%instance = instance

!   Create Radiation Mie Table
!   --------------------------
    call MAPL_GetResource (MAPL, NUM_BANDS, 'NUM_BANDS:', __RC__)

!   Get file names for the optical tables
    call ESMF_ConfigGetAttribute (cfg, self%rad_MieTable(instance)%optics_file, &
                                  label="aerosol_radBands_optics_file:", __RC__ )

    allocate (self%rad_MieTable(instance)%channels(NUM_BANDS), __STAT__ )

    call ESMF_ConfigGetAttribute (cfg, self%rad_MieTable(instance)%channels, label= "BANDS:", &
                                 count=self%rad_MieTable(instance)%nch, rc=status)

    if (rc /= 0) then
       do i = 1, NUM_BANDS
          self%rad_MieTable(instance)%channels(i) = i
       end do
    end if

    allocate (self%rad_MieTable(instance)%mie_aerosol, __STAT__)
    self%rad_MieTable(instance)%mie_aerosol = Chem_MieTableCreate (self%rad_MieTable(instance)%optics_file, rc)
    call Chem_MieTableRead (self%rad_MieTable(instance)%mie_aerosol, NUM_BANDS, self%rad_MieTable(instance)%channels, rc)

!   Create Diagnostics Mie Table
!   -----------------------------
!   Get file names for the optical tables
    call ESMF_ConfigGetAttribute (cfg, self%diag_MieTable(instance)%optics_file, &
                                  label="aerosol_monochromatic_optics_file:", __RC__ )
    call ESMF_ConfigGetAttribute (cfg, self%diag_MieTable(instance)%nch, label="n_channels:", __RC__)
    call ESMF_ConfigGetAttribute (cfg, self%diag_MieTable(instance)%nmom, label="n_moments:", default=0,  __RC__)
    allocate (self%diag_MieTable(instance)%channels(self%diag_MieTable(instance)%nch), __STAT__ )
    call ESMF_ConfigGetAttribute (cfg, self%diag_MieTable(instance)%channels, &
                                  label= "aerosol_monochromatic_optics_wavelength:", __RC__)

    allocate (self%diag_MieTable(instance)%mie_aerosol, __STAT__)
    self%diag_MieTable(instance)%mie_aerosol = Chem_MieTableCreate (self%diag_MieTable(instance)%optics_file, __RC__ )
    call Chem_MieTableRead (self%diag_MieTable(instance)%mie_aerosol, self%diag_MieTable(instance)%nch, &
                            self%diag_MieTable(instance)%channels, rc, nmom=self%diag_MieTable(instance)%nmom)

    ! Mie Table instance/index
    call ESMF_AttributeSet(aero, name='mie_table_instance', value=instance, __RC__)

    ! Add variables to SU instance's aero state. This is used in aerosol optics calculations
    call add_aero (aero, label='air_pressure_for_aerosol_optics',             label2='PLE', grid=grid, typekind=MAPL_R4, __RC__)
    call add_aero (aero, label='relative_humidity_for_aerosol_optics',        label2='RH',  grid=grid, typekind=MAPL_R4,__RC__)
!   call ESMF_StateGet (import, 'PLE', field, __RC__)
!   call MAPL_StateAdd (aero, field, __RC__)
!   call ESMF_StateGet (import, 'RH2', field, __RC__)
!   call MAPL_StateAdd (aero, field, __RC__)

    call add_aero (aero, label='extinction_in_air_due_to_ambient_aerosol',    label2='EXT', grid=grid, typekind=MAPL_R8,__RC__)
    call add_aero (aero, label='single_scattering_albedo_of_ambient_aerosol', label2='SSA', grid=grid, typekind=MAPL_R8,__RC__)
    call add_aero (aero, label='asymmetry_parameter_of_ambient_aerosol',      label2='ASY', grid=grid, typekind=MAPL_R8,__RC__)

    call ESMF_AttributeSet(aero, name='band_for_aerosol_optics',             value=0,     __RC__)

    mieTable_pointer = transfer(c_loc(self), [1])
    call ESMF_AttributeSet(aero, name='mieTable_pointer', valueList=mieTable_pointer, itemCount=size(mieTable_pointer), __RC__)

!    call ESMF_AttributeSet(aero, name='internal_varaible_name', value='SS', __RC__)

!    call ESMF_MethodAdd(AERO, label='aerosol_optics', userRoutine=aerosol_optics, __RC__)


if(mapl_am_i_root()) print*,trim(comp_name),'2G Init END'


    RETURN_(ESMF_SUCCESS)

  end subroutine Initialize

!============================================================================

!BOP
! !IROUTINE: Run 

! !INTERFACE:
  subroutine Run (GC, import, export, clock, rc)

!   !ARGUMENTS:
    type (ESMF_GridComp), intent(inout) :: GC     ! Gridded component 
    type (ESMF_State),    intent(inout) :: import ! Import state
    type (ESMF_State),    intent(inout) :: export ! Export state
    type (ESMF_Clock),    intent(inout) :: clock  ! The clock
    integer, optional,    intent(  out) :: rc     ! Error code:

! !DESCRIPTION: Run method for the Sea Salt Grid Component. Determines whether to run
!               data or computational run method.

!EOP
!============================================================================
!   !Locals
    character (len=ESMF_MAXSTR)       :: COMP_NAME
    type (MAPL_MetaComp), pointer     :: MAPL
    type (ESMF_State)                 :: internal

    logical                           :: data_driven

    __Iam__('Run')

!*****************************************************************************
!   Begin... 

!   Get my name and set-up traceback handle
!   ---------------------------------------
    call ESMF_GridCompGet (GC, NAME=COMP_NAME, __RC__)
    Iam = trim(COMP_NAME) //'::'// Iam

!   Get my internal MAPL_Generic state
!   -----------------------------------
    call MAPL_GetObjectFromGC (GC, MAPL, __RC__)

!   Get parameters from generic state.
!   -----------------------------------
    call MAPL_Get (MAPL, INTERNAL_ESMF_STATE=internal, __RC__)

!   Is SU data driven?
!   ------------------
    call determine_data_driven (COMP_NAME, data_driven, __RC__)

!   Update INTERNAL state variables with ExtData
!   ---------------------------------------------
!    if (data_driven) then
!       call Run_data (GC, import, export, internal, __RC__)
!    else
       call Run1 (GC, import, export, clock, __RC__)
!    end if

    RETURN_(ESMF_SUCCESS)

  end subroutine Run

!============================================================================
!BOP
! !IROUTINE: Run1 

! !INTERFACE:
  subroutine Run1 (GC, import, export, clock, RC)

!   !ARGUMENTS:
    type (ESMF_GridComp), intent(inout) :: GC     ! Gridded component 
    type (ESMF_State),    intent(inout) :: import ! Import state
    type (ESMF_State),    intent(inout) :: export ! Export state
    type (ESMF_Clock),    intent(inout) :: clock  ! The clock
    integer, optional,    intent(  out) :: RC     ! Error code:

! !DESCRIPTION:  Computes emissions/sources for Sea Salt

!EOP
!============================================================================
!   !Locals
    character (len=ESMF_MAXSTR)       :: COMP_NAME
    type (MAPL_MetaComp), pointer     :: mapl
    type (ESMF_State)                 :: internal
    type (ESMF_Grid)                  :: grid
    type (wrap_)                      :: wrap
    type (SU2G_GridComp), pointer     :: self
    type(ESMF_Time)                   :: time

    character(len=3) :: cdow
    integer          :: idow
    integer         :: nymd, nhms, iyr, imm, idd, ihr, imn, isc
    real, pointer, dimension(:,:)        :: lats
    real, pointer, dimension(:,:)        :: lons
    real, dimension(:,:,:), allocatable  :: aircraft_fuel_src
    real, dimension(:,:), allocatable :: so2biomass_src, so2anthro_l1_src, &
                                         so2anthro_l2_src, so2ship_src, so4ship_src, dmso_conc, &
                                         aviation_lto_src, aviation_cds_src, aviation_crs_src
      integer :: nVolcE = 0
      real, pointer, dimension(:)    :: vLatE   => null(), &
                                        vLonE   => null(), &
                                        vSO2E   => null(), &
                                        vElevE  => null(), &
                                        vCloudE => null()
      integer :: nVolcC = 0
      real, pointer, dimension(:)    :: vLatC   => null(), &
                                        vLonC   => null(), &
                                        vSO2C   => null(), &
                                        vElevC  => null(), &
                                        vCloudC => null()
    integer :: n, i, j
    logical :: useVolcanicDailyTables = .false.

#include "SU2G_DeclarePointer___.h"

   __Iam__('Run1')

!*****************************************************************************
!   Begin... 

!   Get my name and set-up traceback handle
!   ---------------------------------------
    call ESMF_GridCompGet (GC, grid=grid, NAME=COMP_NAME, __RC__)
    Iam = trim(comp_name) //'::'// Iam

if(mapl_am_i_root()) print*,trim(comp_name),'2G Run1 BEGIN'

!   Get my internal MAPL_Generic state
!   -----------------------------------
    call MAPL_GetObjectFromGC (GC, mapl, __RC__)

!   Get parameters from generic state.
!   -----------------------------------
    call MAPL_Get (mapl, INTERNAL_ESMF_STATE=internal, __RC__)

#include "SU2G_GetPointer___.h"

!   Get my private internal state
!   ------------------------------
    call ESMF_UserCompGetInternalState(GC, 'SU2G_GridComp', wrap, STATUS)
    VERIFY_(STATUS)
    self => wrap%ptr

!   Extract nymd(yyyymmdd) from clock
!   ---------------------------------
    call ESMF_ClockGet (clock, currTime=time, __RC__)
    call ESMF_TimeGet (time ,YY=iyr, MM=imm, DD=idd, H=ihr, M=imn, S=isc, __RC__)
    call MAPL_PackTime (nymd, iyr, imm , idd)
    call MAPL_PackTime (nhms, ihr, imn, isc)

!   Reset tracer to zero at 0Z on specific day of week
!   --------------------------------------------------
    idow = Chem_UtilIdow(nymd)
    if ( (nhms==0) .and. (idow == self%myDOW) ) then
       cdow = Chem_UtilCdow(nymd)
       DMS = tiny(1.) ! avoid division by zero
       SO2 = tiny(1.) ! avoid division by zero
       SO4 = tiny(1.) ! avoid division by zero
       MSA = tiny(1.) ! avoid division by zero
       if ( MAPL_AM_I_ROOT() ) then
          print *, '<> SU '//cdow//' tracer being set to zero on ', nymd, nhms
       end if
    end if

!   Implicit allocation with Fortran 2003
    so2anthro_l1_src = SU_ANTHROL1
    so2anthro_l2_src = SU_ANTHROL2
    so2ship_src = SU_SHIPSO2
    so4ship_src = SU_SHIPSO4

!   As a safety check, where value is undefined set to 0
    where(1.01*so2anthro_l1_src > undefval)  so2anthro_l1_src = 0.
    where(1.01*so2anthro_l2_src > undefval)  so2anthro_l2_src = 0.
    where(1.01*so2ship_src > undefval)       so2ship_src = 0.
    where(1.01*so4ship_src > undefval)       so4ship_src = 0.

!   Update emissions/production if necessary (daily)
!   -----------------------------------------------
    UpdateEmiss: if(self%nymd_last /= nymd) then
    self%nymd_last = nymd

    aircraft_fuel_src = SU_AIRCRAFT
    so2biomass_src = SU_BIOMASS
    dmso_conc = SU_DMSO
    aviation_lto_src = SU_AVIATION_LTO
    aviation_cds_src = SU_AVIATION_CDS
    aviation_crs_src = SU_AVIATION_CRS

!   As a safety check, where value is undefined set to 0
    where(1.01*so2biomass_src > undefval)    so2biomass_src = 0.
    where(1.01*dmso_conc > undefval)         dmso_conc = 0.
    where(1.01*aircraft_fuel_src > undefval) aircraft_fuel_src = 0.
    where(1.01*aviation_lto_src > undefval ) aviation_lto_src = 0.
    where(1.01*aviation_cds_src > undefval ) aviation_cds_src = 0.
    where(1.01*aviation_crs_src > undefval ) aviation_crs_src = 0.

if(mapl_am_i_root()) print*,'SU2G self%volcano_srcfilen = ',self%volcano_srcfilen

!   Volcanic emissions
!   ------------------
!   Get pointwise SO2 and altitude of volcanoes from a daily file data base
    VolcanicEmissions: if(index(self%volcano_srcfilen,'volcanic_') /= 0) then
       call GetVolcDailyTables (self, nymd, __RC__)

!   Read from the previous volcanoe inventory data
    else 
       if (self%volcano_srcfilen(1:4) /= 'cont') then
          call GetVolcContinuous (nVolcC, vLatC, vLonC, vElevC, vCloudC, vSO2C, __RC__)
          nVolcE = 0
          !if(mapl_am_i_root()) print*,'SU2G test A'
       else if (self%volcano_srcfilen(1:4) == 'expl') then
          call GetVolcExplosive (nymd, nVolcE, vLatE, vLonE, vElevE,vCloudE, vSO2E, __RC__)
          nVolcC = 0
          !if(mapl_am_i_root()) print*,'SU2G test B'
       else
          call GetVolcExplosive (nymd, nVolcE, vLatE, vLonE, vElevE,vCloudE, vSO2E, __RC__)
          call GetVolcContinuous (nVolcC, vLatC, vLonC, vElevC, vCloudC, vSO2C, __RC__)
       end if

!      Combine explosive and continuous data
       self%nVolc = nVolcE + nVolcC

       allocate(self%vLat(self%nvolc), self%vLon(self%nvolc), &
                self%vSO2(self%nvolc), self%vElev(self%nvolc), &
                self%vCloud(self%nvolc))

       if(self%nVolc > 0) then
          if(nVolcE > 0) then
             do i = 1, nVolcE
                self%vLat(i) = vLatE(i)
                self%vLon(i) = vLonE(i)
                self%vElev(i) = vElevE(i)
                self%vCloud(i) = vCloudE(i)
                self%vSO2(i) = vSO2E(i)
             end do
          end if
       if(nVolcC > 0) then
          do i = 1, nVolcC
             self%vLat(i+nVolcE) = vLatC(i)
             self%vLon(i+nVolcE) = vLonC(i)
             self%vElev(i+nVolcE) = vElevC(i)
             self%vCloud(i+nVolcE) = vCloudC(i)
             self%vSO2(i+nVolcE) = vSO2C(i)
          end do
       end if
    endif VolcanicEmissions

!      For these tables vStart and vEnd are not provided, so we assume
!      eruption is throughout day and set to default values
       vStart = -1
       vEnd   = -1






if(mapl_am_i_root()) print*,'SU2G vLat = ',self%vLat
if(mapl_am_i_root()) print*,'SU2G vLon = ',self%vLon
if(mapl_am_i_root()) print*,'SU2G vSO2 = ',self%vSO2
if(mapl_am_i_root()) print*,'SU2G vElev = ',self%vElev
if(mapl_am_i_root()) print*,'SU2G vCloud = ',self%vCloud
if(mapl_am_i_root()) print*,'SU2G vStart = ',self%vStart
if(mapl_am_i_root()) print*,'SU2G vEnd = ',self%vEnd
    endif UpdateEmiss

if(mapl_am_i_root()) print*,trim(comp_name),'2G Run1 END'


    RETURN_(ESMF_SUCCESS)

  end subroutine Run1

!============================================================================
!BOP
! !IROUTINE: Run2 

! !INTERFACE:

  subroutine Run2 (GC, import, export, clock, RC)

    ! !ARGUMENTS:
    type (ESMF_GridComp), intent(inout) :: GC     ! Gridded component 
    type (ESMF_State),    intent(inout) :: import ! Import state
    type (ESMF_State),    intent(inout) :: export ! Export state
    type (ESMF_Clock),    intent(inout) :: clock  ! The clock
    integer, optional,    intent(  out) :: RC     ! Error code:

! !DESCRIPTION: Run2 method for the Dust Grid Component.

!EOP
!============================================================================
! Locals
    character (len=ESMF_MAXSTR)       :: COMP_NAME
    type (MAPL_MetaComp), pointer     :: MAPL
    type (ESMF_State)                 :: internal
    type (wrap_)                      :: wrap
    type (SU2G_GridComp), pointer     :: self

    integer                           :: n
    real, allocatable, dimension(:,:) :: drydepositionfrequency, dqa
    real                              :: fwet
    logical                           :: KIN

real, parameter ::  cpd    = 1004.16


#include "SU2G_DeclarePointer___.h"

    __Iam__('Run2')

!*****************************************************************************
!   Begin... 

!   Get my name and set-up traceback handle
!   ---------------------------------------
    call ESMF_GridCompGet (GC, NAME=COMP_NAME, __RC__)
    Iam = trim(COMP_NAME) // '::' // Iam

!   Get my internal MAPL_Generic state
!   -----------------------------------
    call MAPL_GetObjectFromGC (GC, MAPL, __RC__)

!   Get parameters from generic state.
!   -----------------------------------
    call MAPL_Get (MAPL, INTERNAL_ESMF_STATE=INTERNAL, __RC__)

#include "SU2G_GetPointer___.h"

!do n=1,5
!   if(mapl_am_i_root()) print*,'n = ', n,' : Run2 B SS2G sum(ss00n) = ',sum(SS(:,:,:,n))
!end do

!   Get my private internal state
!   ------------------------------
    call ESMF_UserCompGetInternalState(GC, 'SU2G_GridComp', wrap, STATUS)
    VERIFY_(STATUS)
    self => wrap%ptr


    RETURN_(ESMF_SUCCESS)

  end subroutine Run2


!-----------------------------------------------------------------------------------

  subroutine GetVolcDailyTables (self, nymd, rc)

!   !USES:
    implicit NONE

!   !INPUT PARAMETERS:
    type (SU2G_GridComp), pointer, intent(inout) :: self
    integer, intent(in)                          :: nymd
!   !OUTPUT PARAMETERS:
    integer, optional, intent(out) :: rc   ! Error return code:

!   !DESCRIPTION: ! Data for volcanic emissions comes from the daily inventory of all
!                   volcanos (as represented by the text tables).  We return all the
!                   volcanic emissions (as points, per volcano).

!   !Local Variables
    integer :: i, j, nLines, nCols, nymd1, nhms1
    character(len=255) :: fname
    type(ESMF_Config)  :: cf
    real, pointer, dimension(:) :: vData

    __Iam__('GetVolcDailyTables')

!*****************************************************************************
!   Begin...

!   Daily files (e.g., from AEROCOM)
!   --------------------------------
!   Note: Volcanic emissions in these files are in mass of Sulfur
    nymd1 = nymd
    nhms1 = 120000
    call StrTemplate ( fname, trim(self%volcano_srcfilen), xid='unknown', &
                       nymd=nymd1, nhms=nhms1 )
if(mapl_am_i_root()) print*,'SU2G fname = ',trim(fname)

    cf = ESMF_ConfigCreate()
    call ESMF_ConfigLoadFile(cf, fileName=trim(fname), __RC__)
    call ESMF_ConfigGetDim(cf, nLines, nCols, LABEL='volcano::', __RC__)
    self%nVolc = nLines
    allocate(vData(nCols), self%vLat(nLines),self%vLon(nLines), &
             self%vSO2(nLines), self%vElev(nLines), self%vStart(nLines), &
             self%vEnd(nLines), self%vCloud(nLines), __STAT__)
    self%vStart = -1
    self%vEnd   = -1
    call ESMF_ConfigFindLabel(cf, 'volcano::',__RC__)
    do i = 1, nLines
       call ESMF_ConfigNextLine(cf, rc=rc)
       do j = 1, nCols
          call ESMF_ConfigGetAttribute(cf, vData(j), default=-1.)
       end do
       self%vLat(i)    = vData(1)
       self%vLon(i)    = vData(2)
       self%vSO2(i)    = vData(3) * fMassSO2 / fMassSulfur
       self%vElev(i)   = vData(4)
       self%vCloud(i)  = vData(5)
       if(nCols >= 6) self%vStart(i)  = vData(6)
       if(nCols >= 7) self%vEnd(i)    = vData(7)
    end do

if(mapl_am_i_root()) print*,'SU2G vLat = ',self%vLat
if(mapl_am_i_root()) print*,'SU2G vLon = ',self%vLon
if(mapl_am_i_root()) print*,'SU2G vSO2 = ',self%vSO2
if(mapl_am_i_root()) print*,'SU2G vElev = ',self%vElev
if(mapl_am_i_root()) print*,'SU2G vCloud = ',self%vCloud
if(mapl_am_i_root()) print*,'SU2G vStart = ',self%vStart
if(mapl_am_i_root()) print*,'SU2G vEnd = ',self%vEnd



    call ESMF_ConfigDestroy(cf)
    deallocate(vData, __STAT__)

    RETURN_(ESMF_SUCCESS)

    end subroutine GetVolcDailyTables







end module SU2G_GridCompMod

